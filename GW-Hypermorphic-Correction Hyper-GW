#!/usr/bin/env python3
"""
HyperMorphic Gravitational Wave Analysis
Framework V25: Independent Model Comparison
"""

# --- Step 0: Installation for Google Colab & Imports (Unchanged) ---
try:
    import gwpy
except ImportError:
    print("Installing gwpy... (requires internet connection)")
    import subprocess
    import sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", "gwpy"])
    print("gwpy installed.")

try:
    import pycbc
except ImportError:
    print("Installing pycbc... (requires internet connection, may take a moment)")
    import subprocess
    import sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", "pycbc"])
    print("pycbc installed.")

import numpy as np
import matplotlib.pyplot as plt
from gwpy.timeseries import TimeSeries
from pycbc.waveform import get_td_waveform
from pycbc.psd import from_string
from pycbc.filter import matched_filter, sigmasq
from pycbc.types import TimeSeries as PyCBCTimeSeries
import warnings

# --- Global Constants & Mode Setting (Unchanged) ---
HYPERMORPHIC_MODE = "AdaptiveV13_Stronger"
EPSILON_PHI_VALUE = 1e-50
warnings.filterwarnings('ignore')

# --- Core HNum and HyperMorphic Math (Unchanged) ---
class HNum:
    def __init__(self, value, dimension=0):
        self.dimension = dimension; self.history = []
        current_epsilon_phi = EPSILON_PHI_VALUE
        if isinstance(value, HNum):
            self.value = value.value; self.is_epsilon = value.is_epsilon
        elif isinstance(value, (int, float, complex)):
            if HNum._is_numerically_epsilon(value): self.value = complex(current_epsilon_phi, 0); self.is_epsilon = True
            elif HNum._is_numerically_zero(value): self.value = complex(current_epsilon_phi, 0); self.is_epsilon = True
            else: self.value = complex(value); self.is_epsilon = False
        elif isinstance(value, str) and value == "EPSILON_PHI":
            self.value = complex(current_epsilon_phi, 0); self.is_epsilon = True
        else:
            try:
                val_complex = complex(value)
                if HNum._is_numerically_zero(val_complex): self.value = complex(current_epsilon_phi, 0); self.is_epsilon = True
                else: self.value = val_complex; self.is_epsilon = False
            except (TypeError, ValueError): raise ValueError(f"Cannot initialize HNum with value: {value} of type {type(value)}")
    @staticmethod
    def _is_numerically_zero(val, tol_factor=0.001): return abs(val) < (EPSILON_PHI_VALUE * tol_factor)
    @staticmethod
    def _is_numerically_epsilon(val, tol_factor=10): return abs(val - EPSILON_PHI_VALUE) < (EPSILON_PHI_VALUE * tol_factor)
    def __repr__(self):
        if self.is_epsilon: return f"HNum(ε_ℍ@{EPSILON_PHI_VALUE:.0e}, dim={self.dimension})"
        return f"HNum({self.value.real:.3e}{self.value.imag:+.3e}j, dim={self.dimension})"
    def _prepare_operand(self, other):
        if not isinstance(other, HNum): return HNum(other, self.dimension)
        return other
    def _create_result(self, val, op_desc): return HNum(val, self.dimension)
    def add(self, other, op_ctx="add"):
        other = self._prepare_operand(other)
        if self.is_epsilon and other.is_epsilon: return HNum("EPSILON_PHI", self.dimension)
        raw_val = self.value + other.value
        phi = phi_dynamic_base(self.dimension, abs(raw_val), op_ctx)
        if self.is_epsilon and not other.is_epsilon: result_val = complex_mod(other.value, phi)
        elif not self.is_epsilon and other.is_epsilon: result_val = complex_mod(self.value, phi)
        elif HNum._is_numerically_zero(raw_val): return HNum("EPSILON_PHI", self.dimension)
        else: result_val = complex_mod(raw_val, phi)
        return self._create_result(result_val, f"add({op_ctx})")
    def multiply(self, other, op_ctx="mul"):
        other = self._prepare_operand(other)
        if self.is_epsilon or other.is_epsilon: return HNum("EPSILON_PHI", self.dimension)
        raw_val = self.value * other.value
        psi = psi_dynamic_modulus(self.dimension, abs(raw_val), op_ctx)
        result_val = complex_mod(raw_val, psi)
        if HNum._is_numerically_zero(result_val): return HNum("EPSILON_PHI", self.dimension)
        return self._create_result(result_val, f"mul({op_ctx})")

def complex_mod(z, N):
    if not isinstance(N, (int, float, np.number)) or N <= 0: return z
    real_part = np.fmod(z.real, N); imag_part = np.fmod(z.imag, N)
    return complex(real_part, imag_part)

def phi_dynamic_base(dimension, current_val_magnitude, op_context, params=None):
    # This function remains as the definition of the HM mathematical rules
    global HYPERMORPHIC_MODE
    if params is None: params = {}
    if HYPERMORPHIC_MODE == "AdaptiveV13_Stronger":
        p = {'p1': 1.8, 'p2': 200, 'p3': 10}; p.update(params)
        base_val = 10 + (current_val_magnitude ** p['p1']) + current_val_magnitude * p['p2'] + np.log1p(current_val_magnitude) * p['p3']
        return max(1, int(np.round(base_val)))
    return 100

def psi_dynamic_modulus(dimension, current_val_magnitude, op_context, params=None):
    # This function remains as the definition of the HM mathematical rules
    global HYPERMORPHIC_MODE
    if params is None: params = {}
    if HYPERMORPHIC_MODE == "AdaptiveV13_Stronger":
        p = {'p1': 1.8, 'p2': 100, 'p3': 2.5}; p.update(params)
        mod_val = 150 + (current_val_magnitude ** p['p1']) + current_val_magnitude * p['p2'] + np.log1p(current_val_magnitude) * p['p3']
        return max(1, int(np.round(mod_val)))
    return 150

class HyperMorphicGWAnalyzer:
    def __init__(self):
        self.sample_rate = 4096
        self.gw_events = {
            'GW150914': {'time': 1126259462.4, 'duration': 1.0, 'detectors': ['H1', 'L1'],
                         'params': {'mass1': 36, 'mass2': 29, 'spin1z': 0.3, 'spin2z': -0.4, 'approximant': 'SEOBNRv4_opt'}}
        }

    def fetch_and_process_data(self, event_name, detector):
        # (This function is unchanged)
        print(f"\nAttempting to fetch and process real data for {event_name} ({detector})...")
        event_info = self.gw_events[event_name]
        gps_time, target_duration = event_info['time'], event_info['duration']
        try:
            data_fetched = TimeSeries.fetch_open_data(detector, gps_time - 16, gps_time + 16, sample_rate=self.sample_rate, cache=True, verbose=False, timeout=60)
            data_whitened = data_fetched.whiten(fftlength=4, overlap=2)
            data_filtered = data_whitened.bandpass(30, 350)
            final_data = data_filtered.crop(gps_time - target_duration/2, gps_time + target_duration/2)
            print(f"  Real data for {detector} ({event_name}) processed successfully.")
            delta_f = 1.0 / final_data.duration.value
            psd_pycbc = from_string("aLIGOZeroDetHighPower", len(final_data.value)//2 + 1, delta_f, low_freq_cutoff=20)
            return final_data, psd_pycbc
        except Exception as e:
            print(f"  Error during real data processing for {event_name} ({detector}): {e}")
            return None, None

    def create_gr_template(self, event_params, desired_len):
        # (This function is unchanged)
        print("  Generating standard General Relativity (GR) template...")
        # Create a copy to ensure parameters are not modified elsewhere
        params_copy = event_params.copy()
        hp, _ = get_td_waveform(approximant=params_copy.pop('approximant'), **params_copy,
                                delta_t=1.0/self.sample_rate, f_lower=20)
        hp.resize(desired_len)
        return PyCBCTimeSeries(hp.cyclic_time_shift(hp.start_time), delta_t=1.0/self.sample_rate)

    # =================================================================================
    # --- MODIFIED SECTION: INDEPENDENT HYPERMORPHIC TEMPLATE GENERATION ---
    # =================================================================================
    def _get_hypermorphic_params(self, gr_params):
        """
        This is a placeholder for a true physical calculation using Hypermorphic theory.
        It simulates a new theory by applying HM math to the base physical parameters
        to derive modified "effective" parameters that will generate the waveform.
        This ensures the HM waveform is generated INDEPENDENTLY from the GR waveform.
        """
        print("    -> Applying HM theory to physical parameters...")
        hm_params = gr_params.copy()
        
        # 1. Convert base physical parameters to HNum objects
        m1 = HNum(hm_params['mass1'])
        m2 = HNum(hm_params['mass2'])
        s1z = HNum(hm_params['spin1z'])

        # 2. Apply a hypothetical HM transformation.
        # This is the "new physics" part. Here, we simulate a new interaction
        # where the effective mass is altered by a function of the other mass.
        # This is an arbitrary example, but it follows the correct scientific logic.
        # A real theory would define this transformation.
        m1_effective = m1.add(m2.multiply(HNum(0.01))) # m1_eff = m1 + 0.01*m2
        
        # Let's propose spin is also affected, but by a different interaction.
        s1z_effective = s1z.add(HNum(0.05)) # s1z_eff = s1z + 0.05

        # 3. Convert back to standard numbers to be used by the waveform generator
        hm_params['mass1'] = m1_effective.value.real
        hm_params['spin1z'] = s1z_effective.value.real
        
        print(f"    -> Original mass1: {gr_params['mass1']:.2f}, HM effective mass1: {hm_params['mass1']:.2f}")
        return hm_params

    def create_hypermorphic_template(self, event_params, desired_len):
        """
        Generates the Hypermorphic waveform from the base physical parameters.
        This function is now INDEPENDENT of the GR template.
        """
        print("  Generating INDEPENDENT Hypermorphic (HM) template...")
        
        # 1. Get the 'effective' physical parameters as predicted by HM theory
        hm_event_params = self._get_hypermorphic_params(event_params)

        # 2. Generate a waveform using these new parameters
        # We use the same waveform approximant for a fair comparison of the underlying physics.
        # A more advanced theory might also propose a new approximant.
        params_copy = hm_event_params.copy()
        hp, _ = get_td_waveform(approximant=params_copy.pop('approximant'), **params_copy,
                                delta_t=1.0/self.sample_rate, f_lower=20)
        hp.resize(desired_len)
        return PyCBCTimeSeries(hp.cyclic_time_shift(hp.start_time), delta_t=1.0/self.sample_rate)
    # =================================================================================
    # --- END OF MODIFIED SECTION ---
    # =================================================================================

    def align_and_scale_template(self, template_pycbc, data, psd_pycbc):
        # (This function is unchanged)
        print(f"  Aligning template to data...")
        data_pycbc = PyCBCTimeSeries(data.value, delta_t=data.dt.value)
        # The PSD must have the same length as the data's frequency series
        psd_pycbc.resize(len(data_pycbc.to_frequencyseries()))
        
        snr = matched_filter(template_pycbc, data_pycbc, psd=psd_pycbc, low_frequency_cutoff=30)
        
        peak_idx = abs(snr).numpy().argmax()
        snr_peak_complex = snr[peak_idx]
        time_shift = snr.sample_times[peak_idx]
        
        aligned_template = template_pycbc.cyclic_time_shift(time_shift)
        aligned_template = aligned_template.astype(np.complex128)
        
        sigmasq_val = sigmasq(template_pycbc, psd=psd_pycbc, low_frequency_cutoff=30.0)
        opt_scale = abs(snr_peak_complex) / (sigmasq_val**0.5 if sigmasq_val > 0 else 1)
        aligned_template *= opt_scale
        
        phase_angle = np.angle(snr_peak_complex)
        aligned_template *= np.exp(1j * phase_angle)
        
        return TimeSeries(aligned_template.numpy().real, sample_rate=data.sample_rate.value)

    def calculate_rss(self, data, model):
        # (This function is unchanged)
        return np.sum((data - model)**2)

# --- Main Execution Block ---
if __name__ == "__main__":
    plt.close('all')
    analyzer = HyperMorphicGWAnalyzer()

    print("\n--- Framework V25: Independent Model Comparison ---")
    event_to_analyze = 'GW150914'
    event_info = analyzer.gw_events[event_to_analyze]
    
    results_by_detector = {}
    
    for detector in event_info['detectors']:
        real_data, psd = analyzer.fetch_and_process_data(event_to_analyze, detector)
        if real_data is None:
            results_by_detector[detector] = None
            continue

        # ========================================================================
        # --- MODIFIED LOGIC: GENERATE MODELS INDEPENDENTLY ---
        # ========================================================================
        print("\nStep 1: Generate the two INDEPENDENT models from source parameters.")
        event_params = event_info['params']
        
        # Model 1: Standard General Relativity
        gr_template = analyzer.create_gr_template(event_params, len(real_data.value))
        
        # Model 2: Hypermorphic Theory
        # Note the change here: it now takes the same 'event_params' as the GR
        # model, ensuring it starts from the same physical assumptions.
        hm_template = analyzer.create_hypermorphic_template(event_params, len(real_data.value))
        # ========================================================================
        
        print("\nStep 2: Align EACH model to the data independently.")
        gr_aligned = analyzer.align_and_scale_template(gr_template, real_data, psd)
        hm_aligned = analyzer.align_and_scale_template(hm_template, real_data, psd)

        print("\nStep 3: Calculate RSS for each aligned model against the data.")
        rss_gr = analyzer.calculate_rss(real_data.value, gr_aligned.value)
        rss_hm = analyzer.calculate_rss(real_data.value, hm_aligned.value)
        
        results_by_detector[detector] = {'rss_gr': rss_gr, 'rss_hm': rss_hm}

    # --- Final Network Results (Unchanged logic) ---
    valid_results = {k: v for k, v in results_by_detector.items() if v is not None}
    if valid_results:
        network_rss_gr = sum(res['rss_gr'] for res in valid_results.values())
        network_rss_hm = sum(res['rss_hm'] for res in valid_results.values())

        print("\n\n" + "="*70)
        print("                   INDEPENDENT TEST: FINAL RESULTS")
        print("="*70)
        print(f"  Event Analyzed: {event_to_analyze}")
        print(f"  Detectors Analyzed: {list(valid_results.keys())}\n")
        
        print(f"  Network General Relativity (GR) Model RSS : {network_rss_gr:.6e}")
        print(f"  Network Hypermorphic (HM) Model RSS       : {network_rss_hm:.6e}")
        print("-"*70)

        if network_rss_hm < network_rss_gr:
            improvement = (network_rss_gr - network_rss_hm) / network_rss_gr * 100
            print(f"  CONCLUSION: The independent Hypermorphic model provides a BETTER fit.")
            print(f"  Total Improvement in Residuals: {improvement:.4f}%")
        else:
            worsening = (network_rss_hm - network_rss_gr) / network_rss_gr * 100
            print(f"  CONCLUSION: The standard General Relativity model provides a better fit.")
            print(f"  The HM-Model was worse by: {worsening:.4f}%")
        print("="*70 + "\n")
    else:
        print("\nNo detectors were successfully analyzed.")

    print("\n\n=== Analysis Complete ===")




































